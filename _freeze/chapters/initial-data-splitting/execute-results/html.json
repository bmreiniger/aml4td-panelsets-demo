{
  "hash": "a22736d283da878c1abff6cdf352b496",
  "result": {
    "markdown": "---\nknitr:\n  opts_chunk:\n    cache.path: \"../_cache/initial-data-splitting/\"\n---\n\n\n# Initial Data Splitting {#sec-initial-data-splitting}\n\nWe'll illustrate how to conduct an initial split of your data into different partitions (used for different purposes). \n\n## Requirements\n\n\n\n\n\nYou’ll need 2 packages (<span class=\"pkg\"><a href=\"https://cran.r-project.org/package=caret\">caret</a></span> and <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=tidymodels\">tidymodels</a></span>) for this chapter. \nYou can install them via:\n\n\n::: {.cell hash='../_cache/initial-data-splitting/initial-data-splitting-installs_07427bf772c07aed25d0ab745a405366'}\n\n```{.r .cell-code}\nreq_pkg <- c(\"caret\", \"tidymodels\")\n\n# Check to see if they are installed: \nif (!rlang::is_installed(req_pkg)) {\n  pak::pak(req_pkg)\n}\n```\n:::\n\n\nLet's load the meta package and manage some between-package function conflicts. \n\n\n::: {.cell hash='../_cache/initial-data-splitting/start-tidymodels_e253db365dd72733a51c7709e2171d72'}\n\n:::\n\n\nThe data used here are both in R packages that are already installed. Let's work with the primary data set: the Ames Iowa housing data.\n\n## The Ames Housing Data {#sec-ames-intro}\n\nThese data are in the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=modeldata\">modeldata</a></span> package, which is part of  <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=tidymodels\">tidymodels</a></span>. Let's load the data, subset a few columns, and modify the sale price units. We'll also combine the two bathroom-related columns into a single column. \n\n\n::: {.cell hash='../_cache/initial-data-splitting/setup-ames_84232f5a78a54676a69df04b304b8fc0'}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 2,930\nColumns: 11\n$ Sale_Price   <dbl> 5.332438, 5.021189, 5.235528, 5.387390, 5.278525, 5.29114…\n$ Bldg_Type    <fct> OneFam, OneFam, OneFam, OneFam, OneFam, OneFam, TwnhsE, T…\n$ Neighborhood <fct> North_Ames, North_Ames, North_Ames, North_Ames, Gilbert, …\n$ Year_Built   <int> 1960, 1961, 1958, 1968, 1997, 1998, 2001, 1992, 1995, 199…\n$ Gr_Liv_Area  <int> 1656, 896, 1329, 2110, 1629, 1604, 1338, 1280, 1616, 1804…\n$ Year_Sold    <int> 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 2010, 201…\n$ Lot_Area     <int> 31770, 11622, 14267, 11160, 13830, 9978, 4920, 5005, 5389…\n$ Central_Air  <fct> Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, Y, …\n$ Longitude    <dbl> -93.61975, -93.61976, -93.61939, -93.61732, -93.63893, -9…\n$ Latitude     <dbl> 42.05403, 42.05301, 42.05266, 42.05125, 42.06090, 42.0607…\n$ Baths        <dbl> 1.0, 1.0, 1.5, 2.5, 2.5, 2.5, 2.0, 2.0, 2.0, 2.5, 2.5, 2.…\n```\n:::\n:::\n\n\ntidymodels requires that, for outcome data, any basic transformations should occur before data splitting. \n\n## Simple Data Splitting  {#sec-basic-splitting}\n\nThere are a few main functions for an initial split: \n\n - `rsample::initial_split()`: completely random splits and stratified splits. \n - `rsample::initial_time_split()`: non-random splits for times series; the most recent data are used for testing.\n - `rsample::initial_validation_split()` and `rsample::initial_validation_time_split()`: an initial split into three partitions. \n - `rsample::group_initial_split()`: for situations with repeated measures or other important grouping factors. \n \nMost of our applications will use the first function, where the default is to use 75% for training and 25% for testing. This is determined at random; there is no need to randomly sort the rows before splitting. By default, a simple random split is used. \n\nFor the Ames data, we know that the distribution of sale prices has some outlying points. To deal with this, we'll use a stratified split (on the outcome) using 5 quantiles of the data in `ames`: \n\n\n::: {.cell hash='../_cache/initial-data-splitting/setup-split_2f885bb00c836b3032123efcda486280'}\n::: {.cell-output .cell-output-stdout}\n```\n<Training/Testing/Total>\n<2196/734/2930>\n```\n:::\n:::\n\n\nThe output shows the size of the resulting data sets. To get the two data sets, there are simple accessor functions: \n\n\n::: {.cell hash='../_cache/initial-data-splitting/split-data-sets_a92c9f922b139a8d07a0edd3a0e84f66'}\n\n:::\n\n\nConsistent with the printed output, there are 2,196 data points in the training set and 734 reserved for testing. \n\nWe won't touch on `initial_time_split()` here but only mention that it takes the fraction of the data specified for testing from the bottom/tail of the data frame. Unlike the previous function, the order of the rows matters. \n\n`group_initial_split()` and `initial_validation_split()` are discussed in more detail below.  \n\n## Using the Predictors  {#sec-split-with-predictors}\n\nInstead of using the outcome to partition the data, other columns can be used when applicable. The text mentions using the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=twinning\">twinning</a></span> package ([CRAN page](https://cran.r-project.org/package=twinning)). The same authors have a second approach that can be found in the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=SPlit\">SPlit</a></span> package ([CRAN](https://cran.r-project.org/package=SPlit)). Both are straightforward to use. \n\nMaximum dissimilarity sampling can be conducted using `caret::maxDissim()`. It starts with an initial set of one or more or fewer data points to use as a starter. Unless there is a specific set of points of interest, picking one close to the center of the multivariate predictor distribution might make sense. Here is some code that uses the geographic coordinates as the splitting variables: \n\n\n::: {.cell layout-align=\"center\" hash='../_cache/initial-data-splitting/unnamed-chunk-7_b9563e9dc31e699cd434abd7b5f2bba5'}\n::: {.cell-output-display}\n![](initial-data-splitting_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=40%}\n:::\n:::\n\n\n## Multi-Level Data  {#sec-multilevel-splitting}\n\nThis section will focus on data with a rational grouping of data. For example, medical data might follow patient over time so that there are multiple rows per patient. The patient is the independent experimental unit (IEU), meaning that the data between patients are thought to be independent, and those within a patient are (statistically) related. We want to partition the data so that all of the data for each IEU end up in _either_ the training or test sets but not both. We want to sample the data by the group -- where the group in this example is the patient. \n\nThere are other applications of grouped data but the example data that we'll use fits into the description above: 27 patients were followed and had data collected at four time points. The data are in the <span class=\"pkg\"><a href=\"https://cran.r-project.org/package=nlme\">nlme</a></span> package:\n\n\n::: {.cell hash='../_cache/initial-data-splitting/grouped-data_48bc55c72b876ee61ccffc7542eb8a63'}\n::: {.cell-output .cell-output-stdout}\n```\nRows: 108\nColumns: 4\n$ distance <dbl> 26.0, 25.0, 29.0, 31.0, 21.5, 22.5, 23.0, 26.5, 23.0, 22.5, 2…\n$ age      <dbl> 8, 10, 12, 14, 8, 10, 12, 14, 8, 10, 12, 14, 8, 10, 12, 14, 8…\n$ Subject  <ord> M01, M01, M01, M01, M02, M02, M02, M02, M03, M03, M03, M03, M…\n$ Sex      <fct> Male, Male, Male, Male, Male, Male, Male, Male, Male, Male, M…\n```\n:::\n:::\n\n\nTo use `rsample::group_initial_split()`, we must supply a `group` argument that corresponds to one of the columns in the data. There is also a `prop` argument that specifies the proportion of the groups that should go into the training set. \n\n\n::: {.cell hash='../_cache/initial-data-splitting/grouped-data-split_38fe679e2e509960b578470c7a95a8e4'}\n::: {.cell-output .cell-output-stdout}\n```\n<Training/Testing/Total>\n<72/36/108>\n```\n:::\n:::\n\n\nFrom here, the code to get the resulting data sets is the same as previously shown. We'll also verify that no subjects are in both data sets: \n\n\n::: {.cell hash='../_cache/initial-data-splitting/grouped-split-data-sets_b708a7cdf3031100b8ad99416cd7bdae'}\n::: {.cell-output .cell-output-stdout}\n```\ncharacter(0)\n```\n:::\n:::\n\n\n## Validation Sets  {#sec-three-way-split}\n\nTo add a validation set at the outset, `initial_validation_split()` works the same as `initial_split()`. The `prop` argument requires _two values_ now: the first is the training set proportion, and the second is for the validation set. In this example below, we add 80% to training, 10% to validation, and the remaining 10% to the testing set: \n\n\n::: {.cell hash='../_cache/initial-data-splitting/setup-val-split_dbd6ac22f803b39157646ac8e18bf2c0'}\n::: {.cell-output .cell-output-stdout}\n```\n<Training/Validation/Testing/Total>\n<2342/293/295/2930>\n```\n:::\n:::\n\n\nAgain, the acquisition of data is the same but has the additional use of the `validation()` function: \n \n\n::: {.cell hash='../_cache/initial-data-splitting/split-val-data-sets_c9508f9edd94a123f780ab200a41ebbc'}\n\n:::\n\n\n`rsample::initial_validation_time_split()` does the same thing but based on the ordering of the data (as opposed to random selection). \n\nSuppose a data frame had 100 rows. Using `prop = c(0.8, 0.1)` would place the first 80 rows into training, the next 10 into validation, and the last 10 into testing. Keeping the data appropriately ordered is important when using validation sets in tidymodels. \n\n",
    "supporting": [
      "initial-data-splitting_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}